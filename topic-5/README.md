# Домашнее задание

## Настройка autovacuum с учетом особеностей производительности

**Цель:**

- запустить нагрузочный тест pgbench
- настроить параметры autovacuum
- проверить работу autovacuum

**Описание/Пошаговая инструкция выполнения домашнего задания:**

1. Создать инстанс ВМ с 2 ядрами и 4 Гб ОЗУ и SSD 10GB
2. Установить на него PostgreSQL 15 с дефолтными настройками
3. Создать БД для тестов: выполнить `pgbench -i postgres`
4. Запустить `pgbench -c8 -P 6 -T 60 -U postgres postgres`
5. Применить параметры настройки PostgreSQL из прикрепленного к материалам занятия файла
6. Протестировать заново
    - Что изменилось и почему?
7. Создать таблицу с текстовым полем и заполнить случайными или сгенерированными данным в размере 1млн строк
8. Посмотреть размер файла с таблицей
9. 5 раз обновить все строчки и добавить к каждой строчке любой символ
10. Посмотреть количество мертвых строчек в таблице и когда последний раз приходил автовакуум
11. Подождать некоторое время, проверяя, пришел ли автовакуум
12. 5 раз обновить все строчки и добавить к каждой строчке любой символ
13. Посмотреть размер файла с таблицей
14. Отключить Автовакуум на конкретной таблице
15. 10 раз обновить все строчки и добавить к каждой строчке любой символ
16. Посмотреть размер файла с таблицей
17. Объясните полученный результат
    - Не забудьте включить автовакуум

**Задание со `*`

- Написать анонимную процедуру, в которой в цикле 10 раз обновятся все строчки в искомой таблице.
- Не забыть вывести номер шага цикла.

# Домашняя работа к занятию "MVCC, vacuum и autovacuum." от 26.02.2024
## 1. Создать инстанс ВМ с 2 ядрами и 4 Гб ОЗУ и SSD 10GB
```bash
➜  ~ yc compute instance create \
    --name otus-db-pg-3 \
    --zone ru-central1-d \
    --network-interface subnet-name=otus-subnet-1,nat-ip-version=ipv4 \
    --create-boot-disk size=10G,type=network-ssd,image-folder-id=standard-images,image-family=ubuntu-2004-lts \
    --memory=4 \
    --cores=2 \
    --ssh-key ~/.ssh/yc_key.pub
done (28s)
id: fv4ef7lm18rkoms07g1e
folder_id: b1gffa7irklogm13fdjq
created_at: "2024-03-11T18:07:24Z"
name: otus-db-pg-3
zone_id: ru-central1-d
platform_id: standard-v2
resources:
  memory: "4294967296"
  cores: "2"
  core_fraction: "100"
status: RUNNING
metadata_options:
  gce_http_endpoint: ENABLED
  aws_v1_http_endpoint: ENABLED
  gce_http_token: ENABLED
  aws_v1_http_token: DISABLED
boot_disk:
  mode: READ_WRITE
  device_name: fv4gt7vks8728enmstmk
  auto_delete: true
  disk_id: fv4gt7vks8728enmstmk
network_interfaces:
  - index: "0"
    mac_address: d0:0d:e7:9e:b6:0a
    subnet_id: fl8ogf9pp7nlijj4gl3p
    primary_v4_address:
      address: 192.168.0.23
      one_to_one_nat:
        address: 158.160.132.2
        ip_version: IPV4
gpu_settings: {}
fqdn: fv4ef7lm18rkoms07g1e.auto.internal
scheduling_policy: {}
network_settings:
  type: STANDARD
placement_policy: {}
```

> INFO:
>
> https://postgrespro.ru/products/postgrespro/yandexcloud/standard


## 2. Установить на него PostgreSQL 15 с дефолтными настройками
```bash
➜  ~ ssh otus-db-pg-3
The authenticity of host '158.160.132.2 (158.160.132.2)' can't be established.
...

yc-user@fv4ef7lm18rkoms07g1e:~$ sudo apt update && sudo apt upgrade -y -q
...
```
### Создание файла репозитория
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo sh -c 'echo "deb https://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
```
### Импорт ключа репозитория
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
OK
```
### Обновление списка пакетов
```bash
sudo apt-get update
...
```
### Установка PostgreSQL 15
```bash
sudo apt-get -y install postgresql-15
...
syncing data to disk ... ok
Processing triggers for systemd (245.4-4ubuntu3.23) ...
Processing triggers for man-db (2.9.1-1) ...
Processing triggers for libc-bin (2.31-0ubuntu9.14) ...
```
### Проверка версии PostgreSQL
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ psql --version
psql (PostgreSQL) 15.6 (Ubuntu 15.6-1.pgdg20.04+1)
```
### Запуск и проверка статуса службы PostgreSQL
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo systemctl start postgresql.service
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo -u postgres pg_lsclusters
Ver Cluster Port Status Owner    Data directory              Log file
15  main    5432 online postgres /var/lib/postgresql/15/main /var/log/postgresql/postgresql-15-main.log
```
### Проверка подключения к БД
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo -u postgres psql
psql (15.6 (Ubuntu 15.6-1.pgdg20.04+1))
Type "help" for help.

postgres=#
```
*Настройка и установка PostgreSQL 15 выполнена успешно.*

## 3. Создать БД для тестов: выполнить `pgbench -i postgres`
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo -u postgres pgbench -i postgres
dropping old tables...
NOTICE:  table "pgbench_accounts" does not exist, skipping
NOTICE:  table "pgbench_branches" does not exist, skipping
NOTICE:  table "pgbench_history" does not exist, skipping
NOTICE:  table "pgbench_tellers" does not exist, skipping
creating tables...
generating data (client-side)...
100000 of 100000 tuples (100%) done (elapsed 0.08 s, remaining 0.00 s)
vacuuming...
creating primary keys...
done in 1.20 s (drop tables 0.00 s, create tables 0.01 s, client-side generate 0.10 s, vacuum 0.04 s, primary keys 1.06 s).
```
*Команда `pgbench -i postgres` создает и инициализирует тестовую базу данных postgres, которая может быть использована для проверки производительности системы PostgreSQL с помощью инструмента `pgbench`.*

### Проверим созданные таблицы
```psql
postgres=# \dt
              List of relations
 Schema |       Name       | Type  |  Owner
--------+------------------+-------+----------
 public | pgbench_accounts | table | postgres
 public | pgbench_branches | table | postgres
 public | pgbench_history  | table | postgres
 public | pgbench_tellers  | table | postgres
(4 rows)
```

## 4. Запустить `pgbench -c8 -P 6 -T 60 -U postgres postgres`
```bash
postgres@fv4ef7lm18rkoms07g1e:/home/yc-user$ sudo su postgres
postgres@fv4ef7lm18rkoms07g1e:/home/yc-user$ pgbench -c8 -P 6 -T 60 -U postgres postgres
pgbench (15.6 (Ubuntu 15.6-1.pgdg20.04+1))
starting vacuum...end.
progress: 6.0 s, 777.0 tps, lat 10.226 ms stddev 7.223, 0 failed
progress: 12.0 s, 768.0 tps, lat 10.388 ms stddev 6.910, 0 failed
progress: 18.0 s, 772.2 tps, lat 10.324 ms stddev 6.931, 0 failed
progress: 24.0 s, 770.0 tps, lat 10.372 ms stddev 6.896, 0 failed
progress: 30.0 s, 741.2 tps, lat 10.759 ms stddev 11.170, 0 failed
progress: 36.0 s, 757.8 tps, lat 10.531 ms stddev 8.490, 0 failed
progress: 42.0 s, 772.2 tps, lat 10.330 ms stddev 7.110, 0 failed
progress: 48.0 s, 634.2 tps, lat 12.593 ms stddev 50.384, 0 failed
progress: 54.0 s, 773.3 tps, lat 10.320 ms stddev 7.502, 0 failed
progress: 60.0 s, 713.7 tps, lat 11.178 ms stddev 11.097, 0 failed
transaction type: <builtin: TPC-B (sort of)>
scaling factor: 1
query mode: simple
number of clients: 8
number of threads: 1
maximum number of tries: 1
duration: 60 s
number of transactions actually processed: 44885
number of failed transactions: 0 (0.000%)
latency average = 10.665 ms
latency stddev = 16.681 ms
initial connection time = 17.550 ms
tps = 748.095041 (without initial connection time)
```
*Команда `pgbench -c8 -P 6 -T 60 -U postgres postgres` запускает тестирование производительности базы данных. В данном случае, тестирование проводится с 8 клиентами, выводит отчёт о прогрессе каждые 6 секунд и длится 60 секунд.*

*Тестирование производительности базы данных выполнено успешно. В течение 60 секунд было обработано 44885 транзакций без ошибок. Среднее время выполнения транзакции составило 10.665 мс. Стандартное отклонение времени выполнения транзакции составило 16.681 мс. Производительность системы составила 748.095041 транзакций в секунду.*

## 5. Применить параметры настройки PostgreSQL из прикрепленного к материалам занятия файла
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo nano /etc/postgresql/15/main/postgresql.conf
```
```conf
# - Connection Settings -
max_connections = 40 # по умолчанию 100
# - Memory -
shared_buffers = 1GB # по умолчанию 128MB
work_mem = 6553kB # по умолчанию 4MB
maintenance_work_mem = 512MB # по умолчанию 64MB
# - Planner Cost Constants -
effective_cache_size = 3GB # по умолчанию 4GB
# - Checkpoints -
checkpoint_completion_target = 0.9 # по умолчанию 0.9
min_wal_size = 4GB # по умолчанию 80MB
max_wal_size = 16GB # по умолчанию 1GB
# - Settings -
wal_buffers = 16MB # по умолчанию -1 - задаёт размер, равный 1/32 (около 3%) от shared_buffers, но не меньше чем 64 kB и не больше чем размер одного сегмента WAL (обычно 16 MB).
# - Other Planner Options -
default_statistics_target = 500 # по умолчанию 100
# - Planner Cost Constants -
random_page_cost = 4.0 # по умолчанию 4.0
# - Asynchronous Behavior -
effective_io_concurrency = 2 # по умолчанию 1 в системах, где это поддерживается, и 0 в остальных
```
*Мы изменили критичные настройки для работы PostgreSQL такие как `shared_buffers`, `max_connections` и `wal_level`. Теперь нам необходимо перезапустить службу PostgreSQL для применения изменений.*

### Перезапуск службы PostgreSQL
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo systemctl restart postgresql
```
### Проверка применения параметров
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo -u postgres psql
psql (15.6 (Ubuntu 15.6-1.pgdg20.04+1))
Type "help" for help.

postgres=# SHOW max_connections;
 max_connections
-----------------
 40
(1 row)
```
*Параметр `max_connections` успешно применен. Cледовательно, остальные параметры также применены.*

## 6. Протестировать заново
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo su postgres
postgres@fv4ef7lm18rkoms07g1e:/home/yc-user$ pgbench -c8 -P 6 -T 60 -U postgres postgres
pgbench (15.6 (Ubuntu 15.6-1.pgdg20.04+1))
starting vacuum...end.
progress: 6.0 s, 789.7 tps, lat 10.061 ms stddev 7.576, 0 failed
progress: 12.0 s, 763.8 tps, lat 10.447 ms stddev 7.809, 0 failed
progress: 18.0 s, 769.7 tps, lat 10.363 ms stddev 7.246, 0 failed
progress: 24.0 s, 770.3 tps, lat 10.343 ms stddev 10.283, 0 failed
progress: 30.0 s, 772.2 tps, lat 10.350 ms stddev 7.483, 0 failed
progress: 36.0 s, 757.3 tps, lat 10.529 ms stddev 9.273, 0 failed
progress: 42.0 s, 773.3 tps, lat 10.320 ms stddev 7.590, 0 failed
progress: 48.0 s, 773.8 tps, lat 10.310 ms stddev 7.530, 0 failed
progress: 54.0 s, 728.2 tps, lat 10.966 ms stddev 10.486, 0 failed
progress: 60.0 s, 806.7 tps, lat 9.886 ms stddev 7.563, 0 failed
transaction type: <builtin: TPC-B (sort of)>
scaling factor: 1
query mode: simple
number of clients: 8
number of threads: 1
maximum number of tries: 1
duration: 60 s
number of transactions actually processed: 46238
number of failed transactions: 0 (0.000%)
latency average = 10.353 ms
latency stddev = 8.351 ms
initial connection time = 18.546 ms
tps = 770.591657 (without initial connection time)
```
*После применения параметров настройки PostgreSQL, производительность системы увеличилась.*

### Сравнительная таблица
| Параметр | До | После |
| --- | --- | --- |
| number of transactions actually processed | 44885 | 46238 |
| latency average | 10.665 ms | 10.353 ms |
| latency stddev | 16.681 ms | 8.351 ms |
| tps | 748.095041 | 770.591657 |

*Мы можем наблюдать увеличение количества обработанных транзакций, снижение среднего времени выполнения транзакции и снижение стандартного отклонения времени выполнения транзакции. Так же производительность системы увеличилась с 748.095041 транзакций в секунду до 770.591657 транзакций в секунду.*

### Причины
- мы увеличили количество одновременных подключений к серверу БД настройкой [max_connections](#max_connections), что позволило увеличить количество обработанных транзакций
- увеличили объём памяти, который будет использовать сервер баз данных для буферов в разделяемой памяти настройкой [shared_buffers](#shared_buffers), что позволило правильнее распределить память. Согласно документации PostgreSQL, для выделенного сервера с объёмом ОЗУ 1 ГБ и более, разумным начальным значением shared_buffers будет 25% от объёма памяти. Поскольку мы создали VM с 4 Гб ОЗУ, то увеличение shared_buffers до 1 Гб является разумным решением.
- уменьшили базовый максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов настройкой [work_mem](#work_mem), так-как pgbench не использует сложные запросы, такие как сортировка или хеш-таблицы, то уменьшение этого параметра позволило оптимизировать использование памяти.
    > Инфо:
    >
    > Стандартный встроенный скрипт выполняет запрос TPC-B, который не использует сложные запросы, такие как сортировка или хеш-таблицы. При запуске `pgbench` с параметрами `-r` программа pgbench собирает статистику по каждому оператору и мы можем увидеть структуру встроенного скрипта.

    > Вопрос:
    >
    > Как подобрать оптимальные значения `work_mem` для различных конфигураций серверов? В некоторых источниках указано, что `work_mem` принято считать по формуле `(Total RAM - shared_buffers - maintenance_work_mem)/max_connections` - в нашем случае было бы `(4GB - 1GB - 512MB)/40 ≈ 64 MB`.
- увеличили максимальный объём памяти для операций обслуживания БД настройкой [maintenance_work_mem](#maintenance_work_mem), это позволило улучшить эффективность операций индексации, т.к. в `pgbench` используется вставка и обновление данных, что требует большего объема памяти для операций обслуживания БД.
- уменьшили представление планировщика об эффективном размере дискового кеша, доступном для одного запроса настройкой [effective_cache_size](#effective_cache_size), рекомендуемое значение - 70-80% от объема ОЗУ. Поскольку мы создали VM с 4 Гб ОЗУ, то уменьшение effective_cache_size до 3 Гб является разумным решением.
- значение по умолчанию для [checkpoint_completion_target](#checkpoint_completion_target) - 0.9, фактически мы ничего не поменяли
- увеличили минимальный и максимальный размер WAL настройками [min_wal_size](#min_wal_size) и [max_wal_size](#max_wal_size)
    > Вопрос:
    >
    > Мы указали `max_wal_size = 16GB`, но общий обем диска 10GB, это не приведет к ошибке? Как правильно подобрать размеры `max_wal_size`?
- увеличили размер буфера WAL настройкой [wal_buffers](#wal_buffers) до 16MB. Но и то не больше чем размер одного сегмента WAL (обычно 16 MB). Это обеспечит некоторую резервную мощность для временного хранения записей WAL в памяти перед их записью на диск.
- увеличили значение [default_statistics_target](#default_statistics_target) до 500, что позволит улучшить планирование запросов. Это так-же обеспечит некоторую степень точности для анализа данных в таблицах без излишней нагрузки на систему.
- значение [random_page_cost](#random_page_cost) не меняли, т.к. 4.0 - это значение по умолчанию
- увеличили значение [effective_io_concurrency](#effective_io_concurrency) до 2, т.к. в нашей системе используется SSD, что позволит улучшить производительность ввода-вывода. Значение может быть увеличено в зависимости от количества дисков и их типа.

## 7. Создать таблицу с текстовым полем и заполнить случайными или сгенерированными данным в размере 1млн строк
```psql
postgres=# CREATE TABLE test_table AS
SELECT
    md5(random()::text) AS id,
    md5(random()::text) AS value
FROM
    generate_series(1, 1000000);
SELECT 1000000
postgres=# SELECT COUNT(*) FROM test_table;
  count
---------
 1000000
(1 row)
```
*Таблица `test_table` успешно создана и заполнена 1 млн строками.*

## 8. Посмотреть размер файла с таблицей
### Проверим путь до файла с таблицей `test_table`
```psql
postgres=# SELECT pg_relation_filepath('test_table');
 pg_relation_filepath
----------------------
 base/5/16465
(1 row)
```
### Выведем путь до каталога с данными PostgreSQL
```psql
postgres=# SHOW data_directory;
       data_directory
-----------------------------
 /var/lib/postgresql/15/main
(1 row)
```
### Проверим размер файла с таблицей
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo du -h /var/lib/postgresql/15/main/base/5/16465
97M	/var/lib/postgresql/15/main/base/5/16465
```
*Файл с таблицей `test_table` занимает 97 Мб.*
### Проверим мертвые строки в таблице
```psql
postgres=# SELECT
    relname,
    n_live_tup,
    n_dead_tup,
    trunc(100 * n_dead_tup / (n_live_tup + 1))::float AS "ratio%",
    last_autovacuum
FROM
    pg_stat_user_tables
WHERE
    relname = 'test_table';
  relname   | n_live_tup | n_dead_tup | ratio% |        last_autovacuum
------------+------------+------------+--------+-------------------------------
 test_table |    1000000 |          0 |      0 | 2024-03-12 20:44:16.443923+00
(1 row)
```
*В таблице `test_table` нет мертвых строк.*

## 9. 5 раз обновить все строчки и добавить к каждой строчке любой символ
### Выведем текущее время
```psql
postgres=# SELECT now();
              now
-------------------------------
 2024-03-12 20:47:18.464103+00
(1 row)

```
### Обновим все строки в таблице `test_table` 5 раз и добавим к каждой строчке символ 'x'

```psql
postgres=# DO $$
BEGIN
    FOR i IN 1..5 LOOP
        RAISE NOTICE 'Раунд обновления: %', i;
        UPDATE test_table SET value = value || 'x';
    END LOOP;
END;
$$;
NOTICE:  Раунд обновления: 1
NOTICE:  Раунд обновления: 2
NOTICE:  Раунд обновления: 3
NOTICE:  Раунд обновления: 4
NOTICE:  Раунд обновления: 5
DO
```
*Все строки в таблице `test_table` успешно обновлены 5 раз.*

## 10. Посмотреть количество мертвых строчек в таблице и когда последний раз приходил автовакуум
### Текущее время
```psql
postgres=# SELECT now();
              now
-------------------------------
 2024-03-12 20:49:42.907978+00
(1 row)
```
### Посмотрим количество мертвых строк в таблице `test_table` и когда последний раз приходил автовакуум
```psql
postgres=# SELECT
    relname,
    n_live_tup,
    n_dead_tup,
    trunc(100 * n_dead_tup / (n_live_tup + 1))::float AS "ratio%",
    last_autovacuum
FROM
    pg_stat_user_tables
WHERE
    relname = 'test_table';
  relname   | n_live_tup | n_dead_tup | ratio% |        last_autovacuum
------------+------------+------------+--------+-------------------------------
 test_table |    1000000 |    5000000 |    499 | 2024-03-12 20:44:16.443923+00
(1 row)
```

*В таблице `test_table` 5000000 мертвых строк, последний раз автовакуум приходил в 20:44:16.443923+00.*

### Проверим объем файла с таблицей
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo du -h /var/lib/postgresql/15/main/base/5/16465
579M	/var/lib/postgresql/15/main/base/5/16465
```
*Файл с таблицей `test_table` увеличился до 579 Мб.*

## 11. Подождать некоторое время, проверяя, пришел ли автовакуум
### Текущее время
```psql
postgres=# SELECT now();
              now
-------------------------------
 2024-03-12 20:51:55.445777+00
(1 row)
```

### Проверим количество мертвых строк в таблице `test_table` и когда последний раз приходил автовакуум
```psql
postgres=# SELECT
    relname,
    n_live_tup,
    n_dead_tup,
    trunc(100 * n_dead_tup / (n_live_tup + 1))::float AS "ratio%",
    last_autovacuum
FROM
    pg_stat_user_tables
WHERE
    relname = 'test_table';
  relname   | n_live_tup | n_dead_tup | ratio% |       last_autovacuum
------------+------------+------------+--------+------------------------------
 test_table |    1000000 |          0 |      0 | 2024-03-12 20:50:16.07465+00
(1 row)
```

*В таблице `test_table` нет мертвых строк, последний раз автовакуум приходил в 20:50:16.07465+00. Тем самым, автовакуум выполнился по истечении некоторого времени после обновления строк в таблице `test_table`.*

### Проверим объем файла с таблицей
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo du -h /var/lib/postgresql/15/main/base/5/16465
579M	/var/lib/postgresql/15/main/base/5/16465
```
*Файл с таблицей `test_table` остался на уровне 579 Мб. Тем самым, автовакуум не уменьшил размер файла с таблицей.*

## 12. 5 раз обновить все строчки и добавить к каждой строчке любой символ
```psql
postgres=# DO $$
BEGIN
    FOR i IN 1..5 LOOP
        RAISE NOTICE 'Раунд обновления: %', i;
        UPDATE test_table SET value = value || 'x';
    END LOOP;
END;
$$;
NOTICE:  Раунд обновления: 1
NOTICE:  Раунд обновления: 2
NOTICE:  Раунд обновления: 3
NOTICE:  Раунд обновления: 4
NOTICE:  Раунд обновления: 5
DO
```
## 13. Посмотреть размер файла с таблицей
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo du -h /var/lib/postgresql/15/main/base/5/16465
610M	/var/lib/postgresql/15/main/base/5/16465
```
*Файл с таблицей `test_table` увеличился на 31 Мб - c 579 Мб до 610 Мб*

## 14. Отключить Автовакуум на таблице `test_table`
```psql
postgres=# ALTER TABLE test_table SET (autovacuum_enabled = false);
ALTER TABLE
```

## 15. 10 раз обновить все строчки и добавить к каждой строчке любой символ
```psql
postgres=# DO $$
BEGIN
    FOR i IN 1..10 LOOP
        RAISE NOTICE 'Раунд обновления: %', i;
        UPDATE test_table SET value = value || 'x';
    END LOOP;
END;
$$;
NOTICE:  Раунд обновления: 1
NOTICE:  Раунд обновления: 2
NOTICE:  Раунд обновления: 3
NOTICE:  Раунд обновления: 4
NOTICE:  Раунд обновления: 5
NOTICE:  Раунд обновления: 6
NOTICE:  Раунд обновления: 7
NOTICE:  Раунд обновления: 8
NOTICE:  Раунд обновления: 9
NOTICE:  Раунд обновления: 10
DO
```

## 16. Посмотреть размер файла с таблицей
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ sudo du -h /var/lib/postgresql/15/main/base/5/16465
1.1G	/var/lib/postgresql/15/main/base/5/16465
```
*Файл с таблицей `test_table` увеличился на 490 Мб - c 610 Мб до 1.1 Гб*

### Текущее время
```psql
postgres=# SELECT now();
              now
-------------------------------
 2024-03-12 21:11:23.212021+00
(1 row)

```
### Посмотрим количество мертвых строчек в таблице и когда последний раз приходил автовакуум
```psql
postgres=# SELECT
    relname,
    n_live_tup,
    n_dead_tup,
    trunc(100 * n_dead_tup / (n_live_tup + 1))::float AS "ratio%",
    last_autovacuum
FROM
    pg_stat_user_tables
WHERE
    relname = 'test_table';
  relname   | n_live_tup | n_dead_tup | ratio% |        last_autovacuum
------------+------------+------------+--------+-------------------------------
 test_table |    1000000 |   10000000 |    999 | 2024-03-12 21:00:16.423999+00
(1 row)
```
*В таблице `test_table` 10000000 мертвых строк, последний раз автовакуум приходил в 21:00:16.423999+00.*

### Посмотрим время задержки автовакуума `autovacuum_naptime`
```psql
postgres=# SHOW autovacuum_naptime;
 autovacuum_naptime
--------------------
 1min
(1 row)
```
*Значение `autovacuum_naptime` равно 1 минуте. Тем самым, автовакуум должен был выполнится по истечении 1 мин.*

### Проверим время
```psql
postgres=# SELECT now();
              now
-------------------------------
 2024-03-12 21:17:06.949885+00
(1 row)
```

### Посмотрим количество мертвых строчек в таблице и когда последний раз приходил автовакуум
```psql
postgres=# SELECT
    relname,
    n_live_tup,
    n_dead_tup,
    trunc(100 * n_dead_tup / (n_live_tup + 1))::float AS "ratio%",
    last_autovacuum
FROM
    pg_stat_user_tables
WHERE
    relname = 'test_table';
  relname   | n_live_tup | n_dead_tup | ratio% |        last_autovacuum
------------+------------+------------+--------+-------------------------------
 test_table |    1000000 |   10000000 |    999 | 2024-03-12 21:00:16.423999+00
(1 row)
```
*В таблице `test_table` по прежнему видим 10000000 мертвых строк, последний раз автовакуум приходил в 21:00:16.423999+00. Следовательно, настройка сработала и, автовакуум не выполнился по истечении 1 минуты.*

## 17. Объясните полученный результат
    - Почему файл с таблицей увеличивается?
    - Почему автовакуум не уменьшает размер файла с таблицей?
    - Почему автовакуум не выполняется по истечении 1 минуты?

### Ответ

1. Файл с таблицей увеличивается, т.к. при обновлении строки, PostgreSQL не удаляет старую строку, а создает новую строку и помечает старую строку как мертвую `dead tuple`. Таким образом, количество мертвых строк в таблице увеличивается и размер файла с таблицей увеличивается.

2. Размер файла с таблицей не уменьшается, т.к. автовакуум удаляет мертвые строки и обновляет статистику, но не уменьшает размер файлов с таблицами. Для уменьшения размера файлов с таблицами необходимо выполнить команду `VACUUM FULL` или `CLUSTER`.

3. Автовакуум не выполняется по истечении 1 минуты, т.к. мы отключили автовакуум на таблице `test_table` командой `ALTER TABLE test_table SET (autovacuum_enabled = false);`. Таким образом, автовакуум не выполняется на таблице `test_table` и количество мертвых строк в таблице не уменьшается.

## 18. Включить Автовакуум на таблице `test_table`
### Текущее время
```psql
postgres=# SELECT now();
              now
-------------------------------
 2024-03-12 21:20:02.054881+00
(1 row)
```
### Включим автовакуум на таблице `test_table`
```psql
postgres=# ALTER TABLE test_table SET (autovacuum_enabled = true);
ALTER TABLE
```

## 19. Подождать некоторое время, проверяя, пришел ли автовакуум
### Текущее время
```psql
postgres=# SELECT now();
              now
-------------------------------
 2024-03-12 21:23:35.320115+00
(1 row)
```

### Проверим количество мертвых строк в таблице `test_table` и когда последний раз приходил автовакуум
```psql
postgres=# SELECT
    relname,
    n_live_tup,
    n_dead_tup,
    trunc(100 * n_dead_tup / (n_live_tup + 1))::float AS "ratio%",
    last_autovacuum
FROM
    pg_stat_user_tables
WHERE
    relname = 'test_table';
  relname   | n_live_tup | n_dead_tup | ratio% |        last_autovacuum
------------+------------+------------+--------+-------------------------------
 test_table |    1000869 |          0 |      0 | 2024-03-12 21:21:22.446769+00
(1 row)
```
*В таблице `test_table` нет мертвых строк, последний раз автовакуум приходил в 21:21:22.446769+00. Тем самым, автовакуум выполнился по истечении некоторого времени после включения автовакуума на таблице `test_table`.*

## Логаутимся из VM и останавливаем ее
```bash
yc-user@fv4ef7lm18rkoms07g1e:~$ logout
Connection to 158.160.132.2 closed.
➜  ~ yc compute instance stop otus-db-pg-3
done (14s)
```

# Вывод

Мы ознакомились, изучили и протестировали некоторые настройки PostgreSQL, изменили критичные настройки для работы PostgreSQL такие как `shared_buffers`, `max_connections` и `wal_level`. Также мы создали таблицу с текстовыми полями и заполнили случайными значениями. Написали анонимную процедуру для обновления всех строк в таблице и добавления к каждой строчке символа. Протестировали работу автовакуума на таблице `test_table` и изучили его поведение.


## Выдержки из документации
### <a id="max_connections"></a> max_connections (integer)

    Определяет максимальное число одновременных подключений к серверу БД. По умолчанию обычно это 100 подключений, но это число может быть меньше, если ядро накладывает свои ограничения (это определяется в процессе initdb). Этот параметр можно задать только при запуске сервера.

    Для ведомого сервера значение этого параметра должно быть больше или равно значению на ведущем. В противном случае на ведомом сервере не будут разрешены запросы.

### <a id="shared_buffers"></a> shared_buffers (integer)

    Задаёт объём памяти, который будет использовать сервер баз данных для буферов в разделяемой памяти. По умолчанию это обычно 128 мегабайт (128MB), но может быть и меньше, если конфигурация вашего ядра накладывает дополнительные ограничения (это определяется в процессе initdb). Это значение не должно быть меньше 128 килобайт. Однако для хорошей производительности обычно требуются гораздо большие значения. Если это значение задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен BLCKSZ байт, обычно это 8 КБ). Минимальное допустимое значение зависит от величины BLCKSZ. Задать этот параметр можно только при запуске сервера.

    Если вы используете выделенный сервер с объёмом ОЗУ 1 ГБ и более, разумным начальным значением shared_buffers будет 25% от объёма памяти. Существуют варианты нагрузки, при которых эффективны будут и ещё большие значения shared_buffers, но так как PostgreSQL использует и кеш операционной системы, выделять для shared_buffers более 40% ОЗУ вряд ли будет полезно. При увеличении shared_buffers обычно требуется соответственно увеличить max_wal_size, чтобы растянуть процесс записи большого объёма новых или изменённых данных на более продолжительное время.

    В системах с объёмом ОЗУ меньше 1 ГБ стоит ограничиться меньшим процентом ОЗУ, чтобы оставить достаточно места операционной системе.

### <a id="work_mem"></a> work_mem (integer)

    Задаёт базовый максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов (например, для сортировки или хеш-таблиц), прежде чем будут задействованы временные файлы на диске. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Значение по умолчанию — четыре мегабайта (4MB). Заметьте, что в сложных запросах одновременно могут выполняться несколько операций сортировки и хеширования, и при этом примерно этот объём памяти может использоваться в каждой операции, прежде чем данные начнут вытесняться во временные файлы. Кроме того, такие операции могут выполняться одновременно в разных сеансах. Таким образом, общий объём памяти может многократно превосходить значение work_mem; это следует учитывать, выбирая подходящее значение. Операции сортировки используются для ORDER BY, DISTINCT и соединений слиянием. Хеш-таблицы используются при соединениях и агрегировании по хешу, мемоизации узлов, а также обработке подзапросов IN с применением хеша.

    Операции вычисления хеша обычно более требовательны к памяти, чем равнозначные им операции сортировки. Поэтому ограничение памяти для хеш-таблиц определяется произведением work_mem и hash_mem_multiplier и может превышать обычный базовый объём work_mem.

### <a id="maintenance_work_mem"></a> maintenance_work_mem (integer)

    Задаёт максимальный объём памяти для операций обслуживания БД, в частности VACUUM, CREATE INDEX и ALTER TABLE ADD FOREIGN KEY. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Значение по умолчанию — 64 мегабайта (64MB). Так как в один момент времени в сеансе может выполняться только одна такая операция и обычно они не запускаются параллельно, это значение вполне может быть гораздо больше work_mem. Увеличение этого значения может привести к ускорению операций очистки и восстановления БД из копии.

    Учтите, что когда выполняется автоочистка, этот объём может быть выделен autovacuum_max_workers раз, поэтому не стоит устанавливать значение по умолчанию слишком большим. Возможно, будет лучше управлять объёмом памяти для автоочистки отдельно, изменяя autovacuum_work_mem.

    Заметьте, что для сбора идентификаторов мёртвых кортежей VACUUM может использовать не более 1GB памяти.

### <a id="effective_cache_size"></a> effective_cache_size (integer)

    Определяет представление планировщика об эффективном размере дискового кеша, доступном для одного запроса. Это представление влияет на оценку стоимости использования индекса; чем выше это значение, тем больше вероятность, что будет применяться сканирование по индексу, чем ниже, тем более вероятно, что будет выбрано последовательное сканирование. При установке этого параметра следует учитывать и объём разделяемых буферов PostgreSQL, и процент дискового кеша ядра, который будут занимать файлы данных PostgreSQL, хотя некоторые данные могут оказаться и там, и там. Кроме того, следует принять во внимание ожидаемое число параллельных запросов к разным таблицам, так как общий размер будет разделяться между ними. Этот параметр не влияет на размер разделяемой памяти, выделяемой PostgreSQL, и не задаёт размер резервируемого в ядре дискового кеша; он используется только в качестве ориентировочной оценки. При этом система не учитывает, что данные могут оставаться в дисковом кеше от запроса к запросу. Если это значение задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен BLCKSZ байт, обычно это 8 КБ). Значение по умолчанию — 4 гигабайта (4GB). Если BLCKSZ отличен от 8 КБ, значение по умолчанию корректируется пропорционально.

### <a id="checkpoint_completion_target"></a> checkpoint_completion_target (floating point)

    Задаёт целевое время для завершения процедуры контрольной точки, как долю общего времени между контрольными точками. Значение по умолчанию — 0.9, что распределяет контрольную точку почти по всему доступному интервалу, обеспечивая достаточно стабильную нагрузку ввода-вывода, а также оставляя некоторое время для издержек на завершение процедуры контрольной точки. Уменьшать значение этого параметра не рекомендуется, так как это ускорит данную процедуру, что нежелательно, поскольку приведёт к ускорению ввода-вывода в процессе контрольной точки, и, следовательно, к меньшему объёму ввода-вывода в промежуток времени между завершением процедуры контрольной точки и следующей запланированной контрольной точкой. Этот параметр можно установить только в файле postgresql.conf или в командной строке сервера.

### <a id="min_wal_size"></a> min_wal_size (integer)

    Пока WAL занимает на диске меньше этого объёма, старые файлы WAL в контрольных точках всегда перерабатываются, а не удаляются. Это позволяет зарезервировать достаточно места для WAL, чтобы справиться с резкими скачками использования WAL, например, при выполнении больших пакетных заданий. Если это значение задаётся без единиц измерения, оно считается заданным в мегабайтах. Значение по умолчанию — 80 МБ. Этот параметр можно установить только в postgresql.conf или в командной строке сервера.

### <a id="max_wal_size"></a> max_wal_size (integer)

    Максимальный размер, до которого может вырастать WAL во время автоматических контрольных точек. Это мягкий предел; размер WAL может превышать max_wal_size при особых обстоятельствах, например при большой нагрузке, сбое в archive_command/archive_library или при большом значении wal_keep_size. Если это значение задаётся без единиц измерения, оно считается заданным в мегабайтах. Значение по умолчанию — 1 ГБ. Увеличение этого параметра может привести к увеличению времени, которое потребуется для восстановления после сбоя. Задать этот параметр можно только в postgresql.conf или в командной строке при запуске сервера.

### <a id="wal_buffers"></a> wal_buffers (integer)

    Объём разделяемой памяти, который будет использоваться для буферизации данных WAL, ещё не записанных на диск. Значение по умолчанию, равное -1, задаёт размер, равный 1/32 (около 3%) от shared_buffers, но не меньше чем 64 КБ и не больше чем размер одного сегмента WAL (обычно 16 МБ). Это значение можно задать вручную, если выбираемое автоматически слишком мало или велико, но при этом любое положительное число меньше 32 КБ будет восприниматься как 32 КБ. Если это значение задаётся без единиц измерения, оно считается заданным в блоках WAL (размер которых равен XLOG_BLCKSZ байт, обычно это 8 КБ). Этот параметр можно задать только при запуске сервера.

    Содержимое буферов WAL записывается на диск при фиксировании каждой транзакции, так что очень большие значения вряд ли принесут значительную пользу. Однако значение как минимум в несколько мегабайт может увеличить быстродействие при записи на нагруженном сервере, когда сразу множество клиентов фиксируют транзакции. Автонастройка, действующая при значении по умолчанию (-1), в большинстве случаев выбирает разумные значения.

### <a id="default_statistics_target"></a> default_statistics_target (integer)

    Устанавливает значение ориентира статистики по умолчанию, распространяющееся на столбцы, для которых командой ALTER TABLE SET STATISTICS не заданы отдельные ограничения. Чем больше установленное значение, тем больше времени требуется для выполнения ANALYZE, но тем выше может быть качество оценок планировщика. Значение этого параметра по умолчанию — 100. За дополнительными сведениями об использовании статистики планировщиком запросов PostgreSQL обратитесь к Разделу 14.2.

### <a id="random_page_cost"></a> random_page_cost (floating point)

    Задаёт приблизительную стоимость чтения одной произвольной страницы с диска. Значение по умолчанию равно 4.0. Это значение можно переопределить для таблиц и индексов в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. ALTER TABLESPACE).

    При уменьшении этого значения по отношению к seq_page_cost система начинает предпочитать сканирование по индексу; при увеличении такое сканирование становится более дорогостоящим. Оба эти значения также можно увеличить или уменьшить одновременно, чтобы изменить стоимость операций ввода/вывода по отношению к стоимости процессорных операций, которая определяется следующими параметрами.

    Произвольный доступ к механическому дисковому хранилищу обычно гораздо дороже последовательного доступа, более чем в четыре раза. Однако по умолчанию выбран небольшой коэффициент (4.0), в предположении, что большой объём данных при произвольном доступе, например, при чтении индекса, окажется в кеше. Таким образом, можно считать, что значение по умолчанию моделирует ситуацию, когда произвольный доступ в 40 раз медленнее последовательного, но 90% операций произвольного чтения удовлетворяются из кеша.

    Если вы считаете, что для вашей рабочей нагрузки процент попаданий не достигает 90%, вы можете увеличить параметр random_page_cost, чтобы он больше соответствовал реальной стоимости произвольного чтения. И напротив, если ваши данные могут полностью поместиться в кеше, например, когда размер базы меньше общего объёма памяти сервера, может иметь смысл уменьшить random_page_cost. С хранилищем, у которого стоимость произвольного чтения не намного выше последовательного, как например, у твердотельных накопителей, так же лучше выбрать меньшее значение random_page_cost, например 1.1.
    Подсказка

    Хотя система позволяет сделать random_page_cost меньше, чем seq_page_cost, это лишено физического смысла. Однако сделать их равными имеет смысл, если база данных полностью кешируется в ОЗУ, так как в этом случае с обращением к страницам в произвольном порядке не связаны никакие дополнительные издержки. Кроме того, для сильно загруженной базы данных оба этих параметра следует понизить по отношению к стоимости процессорных операций, так как стоимость выборки страницы, уже находящейся в ОЗУ, оказывается намного меньше, чем обычно.

### <a id="effective_io_concurrency"></a> effective_io_concurrency (integer)

    Задаёт допустимое число параллельных операций ввода/вывода, которое говорит PostgreSQL о том, сколько операций ввода/вывода могут быть выполнены одновременно. Чем больше это число, тем больше операций ввода/вывода будет пытаться выполнить параллельно PostgreSQL в отдельном сеансе. Допустимые значения лежат в интервале от 1 до 1000, а нулевое значение отключает асинхронные запросы ввода/вывода. В настоящее время этот параметр влияет только на сканирование по битовой карте.

    Для магнитных носителей хорошим начальным значением этого параметра будет число отдельных дисков, составляющих массив RAID 0 или RAID 1, в котором размещена база данных. (Для RAID 5 следует исключить один диск (как диск с чётностью).) Однако если база данных часто обрабатывает множество запросов в различных сеансах, и при небольших значениях дисковый массив может быть полностью загружен. Если продолжать увеличивать это значение при полной загрузке дисков, это приведёт только к увеличению нагрузки на процессор. Диски SSD и другие виды хранилища в памяти часто могут обрабатывать множество параллельных запросов, так что оптимальным числом может быть несколько сотен.

    Асинхронный ввод/вывод зависит от эффективности функции posix_fadvise, которая отсутствует в некоторых операционных системах. В случае её отсутствия попытка задать для этого параметра любое ненулевое значение приведёт к ошибке. В некоторых системах (например, в Solaris), эта функция присутствует, но на самом деле ничего не делает.

    Значение по умолчанию равно 1 в системах, где это поддерживается, и 0 в остальных. Это значение можно переопределить для таблиц в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. ALTER TABLESPACE).



